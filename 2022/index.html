<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Happy Holidays</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js"
        }
      }
    </script>

		<script type="module">
      import * as THREE from 'three';

			const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      const light = new THREE.DirectionalLight(0xfff0dd, 1);
      light.position.set(5, 15, 10);
      scene.add(light);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x00003f );
      document.body.appendChild(renderer.domElement);

      const loader = new THREE.TextureLoader();

      const createHouse = async (image, map, bump) => {
        // Add image to mesh
        const texture = await loader.loadAsync(`images/${ image }`);
        const bumpTexture = await loader.loadAsync(`images/${ bump }`);
        const material = new THREE.MeshPhongMaterial({ 
          map: texture,
          alphaTest: 0.5,
          bumpMap: bumpTexture,
          side: THREE.DoubleSide
        });

        const w = texture.image.width;
        const h = texture.image.height;
        const aspectRatio = w / h;

        const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1 / aspectRatio * 2, 32, 1, true);
        const mesh = new THREE.Mesh(geometry, material);




        const hMaterial = new THREE.MeshStandardMaterial({ 
          map: bumpTexture,
          opacity: 0.1,
          transparent: true
        });
        const hGeometry = new THREE.CylinderGeometry(0.51, 0.51, 1 / aspectRatio * 2, 32, 1, true);
        const hMesh = new THREE.Mesh(hGeometry, hMaterial);

        // Create 2D canvas for click map
        const mapCanvas = document.createElement('canvas');
        mapCanvas.width = w;
        mapCanvas.height = h; 
        mapCanvas.hidden = 'hidden';
        document.body.appendChild(mapCanvas);

        const mapContext = mapCanvas.getContext('2d', {
          willReadFrequently: true
        });

        const mapImage = new Image();
        mapImage.addEventListener("load", () => {
          mapContext.drawImage(mapImage, 0, 0);
        });
        mapImage.src = `images/${ map }`;
        
        return {
          mesh: mesh,
          highlight: hMesh,
          map: mapContext
        };
      };

      const createBall = () => {        
        const material = new THREE.MeshPhysicalMaterial({
          roughness: 0.1,  
          transmission: 0.8,  
          thickness: 0.1,
          reflectivity: 0.5
        });

        const geometry = new THREE.SphereGeometry(0.7, 32, 32);
        const mesh = new THREE.Mesh(geometry, material);
        
        return mesh;
      };

      const createBase = () => {
        const material = new THREE.MeshStandardMaterial({
          color: 0x000000
        });

        const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32, 1, true);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y -= 0.5;
        
        return mesh;
      };

      //const ewenHouse = await createHouse('ewen_house.jpg', 'ewen_house_map.jpg');
      //const fionaHouse = await createHouse('fiona_house.jpg', 'fiona_house_map.jpg');
      const combinedHouse = await createHouse('combined_house.png', 'combined_house_map.png', 'combined_house_bump.png');

      const houses = [combinedHouse];

      //houses[0].mesh.position.y = 0.5;
      //houses[1].mesh.position.y = -0.5;

      houses.forEach(house => {
        scene.add(house.mesh);
        scene.add(house.highlight);
      });

      scene.add(createBall());
      scene.add(createBase());

      camera.position.z = 2;

      const raycaster = new THREE.Raycaster();

      const castRay = event => {
        event.preventDefault();
        const x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        const y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        raycaster.setFromCamera({ x, y }, camera);
        const intersects = raycaster.intersectObjects(houses.map(house => house.mesh));

        return intersects.length > 0 ? intersects[0] : null;
      };

      const onMouseDown = event => {
        const intersect = castRay(event);

        if (intersect) {
          const house = houses.find(house => house.mesh === intersect.object);

          if (house) {
            house.mesh.material.bumpScale = 0;
          }
        }
      };

      const onMouseUp = event => {
        const intersect = castRay(event);

        if (intersect) {
          const house = houses.find(house => house.mesh === intersect.object);

          if (house) {
            const context = house.map;

            const w = context.canvas.width;
            const h = context.canvas.height;

            const x = Math.round(intersect.uv.x * w);
            const y = Math.round(h - intersect.uv.y * h);

            const p = context.getImageData(x, y, 1, 1);

            house.mesh.material.bumpScale = 1;
          }
        }
      };


      document.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mouseup', onMouseUp);
        
      function animate() {
        requestAnimationFrame(animate);

				const rotation = 0.001;
        houses.forEach(({ mesh, highlight }) => {
          mesh.rotation.y += rotation;
          highlight.rotation.y += rotation;
        });

        renderer.render(scene, camera);
      }
      animate();
     
		</script>
	</body>
</html>